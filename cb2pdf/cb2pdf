#!/usr/bin/env bash

VERSION='1.1.0'

_usage() {
	cat <<USAGE
USAGE: $(basename "$0") [-hvE] [-d <dpi>] [-e <glob>] <input.cbr|input.cbz> [output.pdf]

OPTIONS:
  -d, --dpi <dpi>                 Set output layout DPI. Default: 300
  -e, --exclude <glob>            Exclude extracted image paths matching glob.
                                  Can be repeated.
  -E, --no-default-excludes       Disable default excludes for hidden files,
                                  AppleDouble files, and __MACOSX paths.
  -h, --help                      Show this help.
  -v, --version                   Show version.
USAGE
}

cb2pdf_main() {
	# export PS4='+ ${BASH_SOURCE}:${LINENO}:${FUNCNAME[0]}() '
	# set -x
	set -euo pipefail

	E_ARGS=16
	E_MISSING_FILE=17
	E_MISSING_APP=18
	E_UNSUPPORTED_EXT=19
	E_NO_IMAGES=20
	E_EXTRACT=21

	[ $# -eq 0 ] && _usage && return

	DPI="${CB2PDF_DPI:-300}"
	USE_DEFAULT_EXCLUDES=1
	EXCLUDE_PATTERNS=()

	while [ $# -gt 0 ]; do
		case "$1" in
		-h | --help)
			_usage
			return
			;;
		-v | --version)
			echo "$(basename "$0") $VERSION"
			return
			;;
		-d | --dpi)
			[ $# -lt 2 ] && _fatal $E_ARGS "Option requires an argument: $1"
			DPI="$2"
			shift 2
			;;
		--dpi=*)
			DPI="${1#*=}"
			shift
			;;
		-e | --exclude)
			[ $# -lt 2 ] && _fatal $E_ARGS "Option requires an argument: $1"
			EXCLUDE_PATTERNS+=("$2")
			shift 2
			;;
		--exclude=*)
			EXCLUDE_PATTERNS+=("${1#*=}")
			shift
			;;
		-E | --no-default-excludes)
			USE_DEFAULT_EXCLUDES=0
			shift
			;;
		--)
			shift
			break
			;;
		-*)
			_fatal $E_ARGS "Unknown option: $1"
			;;
		*)
			break
			;;
		esac
	done

	[ $# -lt 1 ] && _fatal $E_ARGS "Missing arguments."

	INPUT="$1"
	OUTPUT="${2:-${INPUT%.*}.pdf}"

	[ ! -f "$INPUT" ] && _fatal $E_MISSING_FILE "Missing or not a file: $INPUT"
	[[ "$DPI" =~ ^[1-9][0-9]*$ ]] || _fatal $E_ARGS "Invalid DPI: $DPI"

	input_ext="$(echo "${INPUT##*.}" | tr '[:upper:]' '[:lower:]')"
	case "$input_ext" in
	cbz | cbr) ;;
	*) _fatal $E_UNSUPPORTED_EXT "Unsupported input extension: .$input_ext (expected .cbz or .cbr)" ;;
	esac

	_require img2pdf
	_require_extractor "$input_ext"

	echo "Processing $(basename "$INPUT")"

	TMP_DIR="$(mktemp -d)"
	trap _cleanup EXIT INT TERM

	_extract_archive "$INPUT" "$TMP_DIR" "$input_ext"

	IMAGE_FILES=()
	while IFS= read -r -d '' filepath; do
		relative_path="${filepath#"$TMP_DIR"/}"
		if _is_excluded "$relative_path"; then
			continue
		fi
		IMAGE_FILES+=("$filepath")
	done < <(
		find "$TMP_DIR" -type f \
			\( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' \) \
			-print0 | _sort_files
	)

	[ "${#IMAGE_FILES[@]}" -eq 0 ] && _fatal $E_NO_IMAGES "No image files found in archive."

	img2pdf -s "${DPI}dpi" -o "$OUTPUT" "${IMAGE_FILES[@]}"
	echo "Created $OUTPUT"
}

_cleanup() {
	if [ -n "${TMP_DIR:-}" ] && [ -d "$TMP_DIR" ]; then
		rm -rf "$TMP_DIR"
	fi
}

_fatal() {
	local exit_code=$1
	shift
	echo "FATAL: $*" >&2
	exit "$exit_code"
}

_require() {
	missing_bin=0

	for bin in "$@"; do
		if ! command -v "$bin" >/dev/null 2>&1; then
			missing_bin=1
			echo "Required: $bin" >&2
		fi
	done

	if [ $missing_bin -ne 0 ]; then
		_fatal "$E_MISSING_APP" "One or more executables or apps are missing."
	fi
}

_require_extractor() {
	local ext="$1"

	if [ "$ext" = "cbz" ]; then
		command -v 7z >/dev/null 2>&1 || _fatal "$E_MISSING_APP" "Required for .cbz: 7z"
		return
	fi

	if command -v 7z >/dev/null 2>&1 || command -v unrar >/dev/null 2>&1 || command -v unar >/dev/null 2>&1; then
		return
	fi

	_fatal "$E_MISSING_APP" "Required for .cbr: one of 7z, unrar, or unar"
}

_extract_archive() {
	local input="$1"
	local out_dir="$2"
	local ext="$3"
	local err_file

	err_file="$(mktemp)"

	if [ "$ext" = "cbz" ]; then
		if command -v 7z >/dev/null 2>&1; then
			if 7z x -bd -y -o"$out_dir" "$input" >/dev/null 2>"$err_file"; then
				rm -f "$err_file"
				return
			fi
		fi

		rm -f "$err_file"
		_fatal "$E_EXTRACT" "Failed to extract archive: $input"
	fi

	# CBR: try 7z first, then fall back to unrar/unar for methods unsupported by 7z.
	if command -v 7z >/dev/null 2>&1; then
		if 7z x -bd -y -o"$out_dir" "$input" >/dev/null 2>"$err_file"; then
			rm -f "$err_file"
			return
		fi
	fi

	_clear_dir "$out_dir"
	if command -v unrar >/dev/null 2>&1; then
		if unrar x -idq -o+ "$input" "$out_dir/" >/dev/null 2>"$err_file"; then
			rm -f "$err_file"
			return
		fi
	fi

	_clear_dir "$out_dir"
	if command -v unar >/dev/null 2>&1; then
		if unar -quiet -force-overwrite -output-directory "$out_dir" "$input" >/dev/null 2>"$err_file"; then
			rm -f "$err_file"
			return
		fi
	fi

	if grep -qi 'Unsupported Method' "$err_file" 2>/dev/null; then
		rm -f "$err_file"
		_fatal "$E_EXTRACT" "Extractor cannot handle archive method in: $input. Install/use unrar or unar."
	fi

	rm -f "$err_file"
	_fatal "$E_EXTRACT" "Failed to extract archive: $input"
}

_clear_dir() {
	local dir="$1"
	find "$dir" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
}

_sort_files() {
	if sort -zV </dev/null >/dev/null 2>&1; then
		sort -zV
	elif sort -z </dev/null >/dev/null 2>&1; then
		sort -z
	else
		tr '\0' '\n' | sort | tr '\n' '\0'
	fi
}

_is_excluded() {
	local relative_path="$1"
	local pattern

	if [ "$USE_DEFAULT_EXCLUDES" -ne 0 ]; then
		case "$relative_path" in
		__MACOSX/* | */__MACOSX/* | ._* | */._* | .DS_Store | */.DS_Store | Thumbs.db | */Thumbs.db | .* | */.*)
			return 0
			;;
		esac
	fi

	for pattern in "${EXCLUDE_PATTERNS[@]}"; do
		if [[ "$relative_path" == $pattern ]]; then
			return 0
		fi
	done

	return 1
}

cb2pdf_main "$@"
